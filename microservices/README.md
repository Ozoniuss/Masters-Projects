# Microservices Architecture for Beginners

This short document contains my view about microservices, based on various resources I found online. At the moment of writing this, microservices is a hot topic, especially found in Go applications, and the motivation behind writing this document was that after over 1 year of developing microservices, I realized that I wouldn't really be able to tell why we're using them. Of course, there's the classical "it's easier to scale" and "it's easier to develop" type of arguments, but here I will be focusing not on _why_ these points are valid, because they're not universally true, thus rather _when_ they're valid. I will also attempt to explain the difference between a microservices architecture and a monolith architecture, while providing a short proof-of-concept example.
 
> **NB:** As a disclaimer, the document here is just my personal opinion that I've formed on the topic, by working with both microservices and monoliths, reading resources, watching videos, talking to other people etc. I'm open to update the article based on feedback. Resources I've consulted are linked at the bottom of the document, and referenced in text.

So what's a monolith and what's a microservice?
-----------------------------------------------

Generally, I tend to view monoliths as nothing more than very big programs, and microservices as smaller programs running together. A good question to ask here would be, how big is a big program? What's the line that separates a monolith from a smaller microservice? Unfortunately, there is no clear answer to these questions because it largely depends on context. However, a general consensus would be that if the entire application runs as a single unit of execution (so you run it entirely at once) it's a monolith. If running the application consists of running individual apps separately, then we have microservices.

This description is cutting some corners, only providing an intuitive overview of the difference between the architectures. The term "app" or "application" used above is intentionally very broad, because it's not easy to put together a definition for the pieces that constitute a software application. [[1]](https://www.pcmag.com/encyclopedia/term/application-software) Take for example an application presenting a lighter separation: a frontend client running separately and communicating with a backend, that is connected to a database management system. Would this be considered a microservices application, just because the backend, frontend and the database management system are running in separate units of execution?

As described by [microservices.io](https://microservices.io/) [[2]](https://microservices.io/) and [Microsoft](https://learn.microsoft.com/en-us/azure/architecture/guide/architecture-styles/microservices) [[10]](https://learn.microsoft.com/en-us/azure/architecture/guide/architecture-styles/microservices), in order for an application's architecture to be considered microservices, it should come with independently deployable modules, that are loosely coupled and modeled around the bussiness requirements of the application. The modules should be developed and scaled individually, often by separate teams of the organization. With this definition in mind, I would consider the example above to classify as a microservices architecture, albeit a rather simple one which is not quite what the term "microservices" is generally used for nowadays. The bussiness separation here (and thus the microservices) would be the user experience, taken care by the frontend module, and the server supplying the data, comprised of the backend and the database management server. Do note that I intentionally included the database management server as part of the service; databases are generally thought as being included because they hold the bussiness data that the service is operating with. In fact, there are even design pattern suggesting to separate a large application database containing all the data across smaller databases associated with individual microservices. [[18]](https://microservices.io/patterns/data/database-per-service.html)

Perhaps not as obvious, but running multiple instances of the same monolith application, most often with a load balancer to even out the processing toll on each instance, doesn't classify as having multiple microservices, but rather as horizontal scaling. The core logic is executed inside a single computing instance, and not spread accross multiple ones. Therefore, when you make a request to this "wall" of applications, the load balancer routes it to a single instance which processes it, without communicating with the other instances (note that communication with other shared processes such as database systems may still be involved, though). With a microservices architecture, processing a request could involve traversing multiple of these "small" applications before returning a result, as we have with the [API Gateway Pattern.](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern) [[3]](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern)

I'll further explain this point by providing the example from [TechWorld with Nana's](https://www.youtube.com/@TechWorldwithNana) YouTube video ["Microservices explained - the What, Why and How?"](youtube.com/watch?v=rv4LlmLmVWk) [[4]](youtube.com/watch?v=rv4LlmLmVWk). Given an online shop application, you might find multiple components: user authentication, poduct catalogue, shopping cart, notification system and a payment system. If there is a single codebase and starting the application implies running all these components together as a single unit, it's considered to be a monolith application. If you run each of these components separately as smaller applications and have them communicate with each other over network calls by defining an interface for each of them, that's thought of as a microservices architecture.

Note that it's still perfectly valid to have separate modules (and separate teams working on them) in a monolithic application, which is often referred to as a modular monolith. [[20]](https://www.jrebel.com/blog/what-is-a-modular-monolith) There are articles out there promoting modular architectures over microservices in certain use cases. [[19]](https://blogs.newardassociates.com/blog/2023/you-want-modules-not-microservices.html) The section [When to use microservices](#when-to-use-microservices) discusses in more detail when I think each approach is better suited.

Monoliths vs Mircoservices
--------------------------

In this next section, I will explain the fundamental differences between the two architectures. This is an objective comparison, and doesn't attempt to glamorize one architecture over the other, but rather how various parts of the development process looks like with each architecture. The ideal architecture of an application is largely dependent on the bussiness needs and the scale it is trying to reach, thus coming up with a one-size-fits-all formula to determine the ideal choice for a generic project is not possible.

**Runtime**

That being said, let's first resume on a previous point, that a monolith runs as a single unit of execution, whereas microservices run as separate independent modules. This property has direct consequences on the technology choice. Usually, monoliths are written with a single technology stack, often even with the same programming language. [[5]](https://ginbits.com/monolithic-microservices-architecture-a-harmonized-dance/) [[6]](https://microservices.io/patterns/monolithic.html) In contrast, microservices are smaller applications that can run independently, exposing certain interfaces for communication. It is not a hard requirement to write the services using the same technology, e.g. one service may be written in Python, whereas another service may be written in Go.

It is worth mentioning though that sometimes programs are developed with multiple languages, even when they run as a single process. [[7]](https://stackoverflow.com/questions/636841/how-do-multiple-languages-interact-in-one-project)

Another aspect to consider is that having a single runtime makes interprocess communication generally simpler. One trap that developers can fall into when designing microservices is thinking of network calls (which is how microservices communicate) as function calls within the same program. Having to communicate over the network comes with several considerations that are well portrayed in the article "Fallacies of Distributed System" by L Peter Deutsch and others at Sun Microsystems. [[17]](https://architecturenotes.co/fallacies-of-distributed-systems/)

**Managing code and versioning**

Moving on, the coding process is slightly different. In monoliths, the effects of modifying one part of the application often propagate throughout the entire application. When code changes, it is possible that other parts of the application break, if they're not compatible with the changes. On the other hand, adding the code for one feature could potentially require touching a lot of places. This is less noticeable within a single microservices, where there is generally less code. However, this doesn't mean that a change to a single microservice never affects the others: updates to the communication interfaces may incur changes to the service communication, be it with RPC calls, HTTP requests etc. In fact, the lack of governance found in this architecture may require having to apply some project-wide standards in addition to the existing service-wide standards, which is an extra overhead for the team.

In terms of external code, dependency management may be less flexible with monoliths, particularly because it's not always possible to support multiple versions of the same dependency, or at least not easily, if that is desired. [[8]](https://boyl.es/post/two-versions-same-library/) With microservices though, dependencies are not shared, but this also means that each microservice has to import its own dependencies, often leading to having to repeat the same dependencies across the entire project. Although, in practice, this is usually not a problem, since most languages offer ways to handle external modules easily, e.g. via [go modules](https://go.dev/blog/using-go-modules) in Go, and it's often the case that microservices are developed by separate teams, making repeated dependencies less visible.

Consequently, it's also inherently more difficult to share and reuse code in a microservices architecture, when in monoliths it's mostly just a matter of following principles such as [SOLID](https://www.baeldung.com/solid-principles) for writing more maintainable and reusable code. Shared functionality such as database pagination, graceful server shutdown or testing setups may be written and packaged in a common module, but this requires additional work to make the package available, and doesn't play well if using different programming languages for the microservices.

Next, how about actually managing and versioning the code? The usual setup in a monolith is in a single repo (or monorepo), with common versioning strategies and working flows such as git-flow [[11]](https://nvie.com/posts/a-successful-git-branching-model/) and github flow [[12]](https://docs.github.com/en/get-started/quickstart/github-flow). However, it becomes less clear whether the code for a microservices application should live in a single repo, or in multiple repositories (polyrepo). With a monorepo, the code for each service usually resides in a folder at the project level, thus code management is simpler and shared code and libraries can live in the same repo. The downside to this is that it introduces the tendency to develop code with tighter coupling, not ideal in a microservices setup. Not only that, but once the codebase grows, interacting with the repository becomes harder (e.g. cloning the entire codebase takes longer), making the process similar to monoliths. 

Polyrepos help avoid some of this problems, while also providing a much easier approach to versioning. Since version tags such as git tags [[14]](https://docs.github.com/en/rest/git/tags?apiVersion=2022-11-28) refer to a single commit which is part of a repository, polyrepos offer the possibility to individually version each services following a versioning schema like semantic versioning. [[15]](https://semver.org/) Platforms such as GitLab also come with solutions such as GitLab Groups [[16]](https://docs.gitlab.com/ee/user/group/) for grouping separate repositories together. This doesn't mean that polyrepos don't have their own challenges: for instance they're generally harder to manage. A feature that requires changes to multiple microservices cannot be shipped through a single atomic operation like a merge request. The monorepo management described previously also becomes more tedious.

**Builds and deployments**

The building and deployment process is also different, since monoliths are generally built and deployed as a single package. Changes to any part of the code in a monolithic application requires re-building and re-packaging the application, which can be especially noticeable when the application grows large enough that it takes a lot of time to compile it. On the other hand, while the microservices are separately built and packaged themselves, the process is individual for each one: deploying changes to one microservice doesn't affect the other microservices, making it possible to apply changes even while the other microservices are running (unless there are breaking changes to the communication interfaces, as explained in a previous paragraph). This has a direct impact on scalability, since each service can be scaled individually based on the load. Another important deployment element are CI/CD pipelines. Due to the nature of how updates are delivered in a microservices architecture, CI/CD setups are often more complex, especially in monorepos, since CI/CD pipelines can usually only be defined per project [[13]](https://docs.gitlab.com/ee/ci/pipelines/), and thus require more management in order to trigger a pipeline only for a specific service.

**Teamwork**

Now, it's time to discuss the effects of the points above on team interaction. Software is generally developed in teams, and teams often work on different parts of the application. This can be seen with both architectures: in monoliths, teams often work on different modules, and with microservices, teams often work on individual services. Monoliths tend to require more synchronization between teams before pushing any new changes, to minimize the risk of potential side effects, such as breaking code changes or dependency conflicts.

Not only the communication between teams is different, but also boarding new team members brings different challenges. As mentioned in [TechWorld with Nana's](https://www.youtube.com/@TechWorldwithNana), as well as [Gaurav Sen's](https://www.youtube.com/@gkcs) video ["What is a microservice architecture and it's advantages?"](https://www.youtube.com/watch?v=qYhRvH9tJKw), a monolith architecture often requires all team members to have some knowlledge about the entire system, in order to minimize the risk of side effects and improving development efficiency. This is not necessarily the case with microservices, where if working on a single microservice it's possible to treat the others as "black boxes" and know only about the communication interfaces and the computations to be performed for each operation. Of course, this mindset may be applied to monoliths as well, e.g. you might only take a look at the functions exposed by a module and their documentation, similar to [C++ header files](https://learn.microsoft.com/en-us/cpp/cpp/header-files-cpp?view=msvc-170), but microservices tend to force it, e.g. team members might not even have access to the code of other services. This shows an additional contrast between the two: it's easier to restrict developer access to the internal code of other microservices.

**Summary**

This section focued on illustrating the various similarities and differences between the two popular architectures. It's easy to think of microservices as individual modules that work together to essentially provide the entire application. Though, a natural question that pops up here would be, when to actually use microservices? We have seen so far what can be the potential challenges that come with adopting a microservices architecture, so when do they bring benefits? There is even an article suggesting that the concept of microservices is often misinterpreted and a modular application would often times be better suited. [[19]](https://blogs.newardassociates.com/blog/2023/you-want-modules-not-microservices.html) In the next section, I will give my own opinion when I think a microservices architecture starts becoming beneficial.

When to use microservices?
-------------------------

Here, I will briefly explain my point of view regarding when to use microservices and when to use monoliths. Microservices do come with certain advantages of course, but in my opinion they only start to show when working at large scale. For instance, if I were to work on a small-scale personal project there's no way I would adopt a microservices architecture, at least not right off the bat. There would be way too many considerations that would likely just slow down getting the app to a working state considerably, which is an important milestone. In particular, think about defining the microservices and their interaction, or setting up their development environment when just getting started. It takes reaching a certain amount of application traffic, a certain amount of code to maintain and a certain amount of people in the team in order to have real benefits over the downsides brought by having to model their communication over network calls.

I'd also like to end by providing some of my thoughts regarding why they might have some advantages over simply modularizing the application code in a monolith. While in a monolith thinking about decoupling code stands as a core principle, microservices _force_ you to decouple code. And finally, microservices tend to integrate very well with distributed tools in containerized architectures, such as Kubernetes, which provide significant help when scaling them horizontally and distributing them.

Resources
---------

1. https://www.pcmag.com/encyclopedia/term/application-software
2. https://microservices.io/
3. https://learn.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern
4. youtube.com/watch?v=rv4LlmLmVWk
5. https://ginbits.com/monolithic-microservices-architecture-a-harmonized-dance/
6. https://microservices.io/patterns/monolithic.html
7. https://stackoverflow.com/questions/636841/how-do-multiple-languages-interact-in-one-project
8. https://boyl.es/post/two-versions-same-library/
9. https://www.youtube.com/watch?v=qYhRvH9tJKw
10. https://learn.microsoft.com/en-us/azure/architecture/guide/architecture-styles/microservices
11. https://nvie.com/posts/a-successful-git-branching-model/
12. https://docs.github.com/en/get-started/quickstart/github-flow
13. https://docs.gitlab.com/ee/ci/pipelines/
14. https://docs.github.com/en/rest/git/tags?apiVersion=2022-11-28
15. https://semver.org/
16. https://docs.gitlab.com/ee/user/group/
17. https://architecturenotes.co/fallacies-of-distributed-systems/
18. https://microservices.io/patterns/data/database-per-service.html
19. https://blogs.newardassociates.com/blog/2023/you-want-modules-not-microservices.html
20. https://www.jrebel.com/blog/what-is-a-modular-monolith