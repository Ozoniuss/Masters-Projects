System models:

================================================================================

CRASH-STOP: At some point t the process stops executing any local computation
and does not send any more messages to other processes. It never recovers after
the crash. A correct process never crashes and executes an infinite number of
steps.

In crash-stop models, the algorithm should not rely on processes to recover.

================================================================================

Omission: a process does not send or receive a message (e.g. buffer overflows,
network congestions).

CRASH-RECOVERY: A fauly process either crashes and never recovers or keeps 
crashing and recovering infinitely often. A correct process crashes and recovers
a finite amount of time. Crashes are similar to omissions, except processes
may suffer amnesia (losing internal state).

A stable storage (log): persistent storage in the system.

A <Recovery> event is automatically generated by the runtime when the process
recovers, similar to <Init>.

================================================================================

Eavesdropping: an attacker retrieves some sensitive information.

CRASH-ARBITRARY(BYZANTINE): A faulty process may deviate in any conceivable way
from the algorithm assigned to it.



================================================================================
FAIL-STOP (where processes can fail by crashing but the crashes can be reliably
detected by all the other processes):

Crash-stop process abstraction, perfect links, perfect failure detector.
================================================================================
FAIL-NOISY (where processes can fail by crashing and the crashes can
be detected, but not always in an accurate manner - accuracy is only eventual):

Crash-stop process abstraction, perfect links, eventually perfect failure
detector or eventual leader detector.
================================================================================
FAIL-SILENT (where process crashes can never be reliably detected):

Crash-stop process abstraction, perfect links, NO failure detector or leader 
election.
================================================================================
FAIL-RECOVERY (where processes can crash and later recover and still participate
in the algorithm):

Crash-recovery process abstraction (potential amnesia, losing internal state),
stubborn links, eventual leader detector.
================================================================================
FAIL-ARBITRARY (FAIL-SILENT-ARBITRARY) (where processes can deviate arbitrarily
from the pro￾tocol specification and act in malicious, adversarial ways):

Crash-arbitrary process abstraction, authenticated perfect links.

Using the Byzantine eventual leader detector -> FAIL-NOISY-ARBITRARY
================================================================================


LINKS.
================================================================================
FAIR-LOSS-LINK (Fair-Loss-Point-To-Point-Link, fll):

Request: <fll, Send | q, m>: Requests to send message m to process q.
Indication: <fll, Deliver | p, m>: Delivers message m sent by process p.

FLL1: Fair-loss: If a CORRECT process p infinitely often sends a message m to a
CORRECT process q, then q delivers m an infinite number of times.
FLL2: Finite duplication: If a CORRECT process p sends a message m a finite
number of times to process q, then m cannot be delivered an infinite number of
times by q. (ensures that the network does not repeatedly perform more
retransmissions than that performed by the sending process)
FLL3: No creation: If some process q delivers a message m with sender p, then m
was previously sent to q by process p.
================================================================================
STUBBORN LINK (Stubborn-Point-To-Point-Link, sll)

Request: <sl, Send | q, m>: Requests to send message m to process q.
Indication: <sl, Deliver | p, m> : Delivers message m sent by process p.

SL1: Stubborn delivery: If a correct process p sends a message m once to a
correct process q, then q delivers m an infinite number of times.
SL2: No creation: If some process q delivers a message m with sender p, then m
was previously sent to q by process p.
================================================================================
PERFECT LINK (Perfect-Point-To-Point-Link, pll)

Request: <pl, Send | q, m>: Requests to send message m to process q.
Indication: <pl, Deliver | p, m>: Delivers message m sent by process p.

PL1: Reliable delivery: If a correct process p sends a message m to a correct
process q, then q eventually delivers m.
PL2: No duplication: No message is delivered by a process more than once.
PL3: No creation: If some process q delivers a message m with sender p, then m
was previously sent to q by process p.
================================================================================


QUORUMS.




Registers:

(1, N): one process can write and all N processes can read.
(N, N): everybody can write and read.

atomic:

nnar

up tack (⊥): initial value